Spring容器的refresh() ：容器的创建刷新
1.prepareRefresh();刷新前的预处理
    1）initPropertySources()；初始化一些属性设置，子类自定义个性化的属性设置方法；
    2）getEnvironment().validateRequiredProperties();检验属性的合法性等
    3）this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();保存容器中的一些早期的事件
2.obtainFreshBeanFactory();获取beanFactory
    1）obtainFreshBeanFactory();刷新【创建】BeanFactory
        a. GenericApplicationContext类 调用无参构造器创建一个 this.beanFactory = new DefaultListableBeanFactory()并设置id;
    2）getBeanFactory();返回GenericApplicationContext创建的BeanFactory对象
    3）将创建的BeanFactory【DefaultListableBeanFactory】返回
3.prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）
    1）设置类加载器、支撑表达式解析器
    2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】
    3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware等等
    4）注册可以解析的自动自动装配，我们能直接在任何组件中自动注入BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext
    5）添加BeanPostProcessor【ApplicationListenerDetector】
    6）添加编译时的AspectJ
    7）给BeanFactory中注册一些能用的组件：environment【ConfigurableEnvironment】、SystemProperties【Map<String,Object>】
4.postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作
    1）子类通过重写这个方法在BeanFactory创建并预准备完成以后做进一步的设置
================================================以上是BeanFactory的创建以及预准备工作===========================================================
5.invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法
    BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的
       两个接口：BeanFactoryPostProcessors、BeanDefinitionRegistryPostProcessor
    1）先执行BeanDefinitionRegistryPostProcessor 【postProcessor.postProcessBeanDefinitionRegistry(registry)】
        a.获取所有的BeanDefinitionRegistryPostProcessor
        b.看优先级排序，执行顺序为实现了PriorityOrdered优先级的BeanDefinitionRegistryPostProcessor
        c.再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor
        d.最后执行没有实现任何优先级或顺序接口的BeanDefinitionRegistryPostProcessor
    2）再执行BeanFactoryPostProcessor 【postProcessor.postProcessBeanFactory()】
        a.获取所有的BeanFactoryPostProcessor
        b.看优先级排序，执行顺序为实现了PriorityOrdered优先级的BeanFactoryPostProcessor
        c.再执行实现了Ordered顺序接口的BeanFactoryPostProcessor
        d.最后执行没有实现任何优先级或顺序接口的BeanFactoryPostProcessor
6.registerBeanPostProcessors(beanFactory);注册BeanPostProcessors（Bean的后置处理器）
        不同接口类型的BeanPostProcessor在Bean创建前后的执行时机是不一样的 【beanFactory.addBeanPostProcessor(postProcessor)】
        BeanPostProcessor
        DestructionAwareBeanPostProcessor
        InstantiationAwareBeanPostProcessor
        SmartInstantiationAwareBeanPostProcessor
        MergedBeanDefinitionPostProcessor
    1）获取所有的BeanPostProcessor，后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级
    2）先注册PriorityOrdered优先级接口的BeanPostProcessor，添加到BeanFactory中
    3）再注册Ordered排序接口的BeanPostProcessor
    4）最后注册没有实现任何优先级接口的BeanPostProcessor
    5）最终注册MergedBeanDefinitionPostProcessor
    6）注册一个ApplicationListenerDetector来在Bean创建完成后检查是否是ApplicationListener
       如果是则执行this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);保存
7.initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）
    MessageSource：取出国际化配置文件的某个key值；能按照区域信息获取
    1）获取BeanFactory
    2）看容器中是否有id为messageSource的组件
       有则赋值给messageSource，没有则创建一个DelegatingMessageSource
    3）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource
       调用MessageSource.getMessage()方法
    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);